<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>Chess Game</title>
        <style>
            body {
                background-color: #7393B3;
                color: white;
                font-family: Arial, Helvetica, sans-serif;
                margin: 0;
            }
            /* chess board styling */
            #gameboard {
                display: grid;
                grid-template-columns: 2rem repeat(8, 4rem);
                grid-template-rows: repeat(8, 4rem) 2rem;
                width: max-content;
            }
            #spacer {
                padding: 2rem 2rem 0 0;
                width: max-content;
                margin: 0 auto;
                border-radius: 6px;
                background-color: #E1C16E;
            }
            .field {
                width: 4rem;
                height: 4rem;
                padding: 0;
                clear:none;
            }
            .dark {
                background-color: #CD7F32;
                display: inline-block;
            }
            .light {
                background-color: #FFE9C5;
                display: inline-block;
            }
            .piece {
                z-index: 5;
            }
            .row8 {
                grid-row: 1;
            }
            .row7 {
                grid-row: 2;
            }
            .row6 {
                grid-row: 3;
            }
            .row5 {
                grid-row: 4;
            }
            .row4 {
                grid-row: 5;
            }
            .row3 {
                grid-row: 6;
            }
            .row2 {
                grid-row: 7;
            }
            .row1 {
                grid-row: 8;
            }
            .notationRow {
                grid-row: 9;
                line-height: 2rem;
            }
            .colA {
                grid-column: 2;
            }
            .colB {
                grid-column: 3;
            }
            .colC {
                grid-column: 4;
            }
            .colD {
                grid-column: 5;
            }
            .colE {
                grid-column: 6;
            }
            .colF {
                grid-column: 7;
            }
            .colG {
                grid-column: 8;
            }
            .colH {
                grid-column: 9;
            }
            .notationCol {
                grid-column: 1;
                line-height: 4rem;
            }
            .notation {
                text-align: center;
            }
            /*--------*/
            #title {
                text-align: center;
            }
            .marker {
                color: #008080;
                font-size: xx-large;
                text-align: center;
                line-height: 4rem;
                position: relative;
                z-index: 10;
                cursor: pointer;
            }
            p {
                width:fit-content;
            }
            .catch {
                background-color: red;
            }
            #ui {
                display: grid;
                grid-template-columns: 50% 50%;
                grid-template-rows: auto;
            }
            .turnIndicatorContainer {
                padding: 2rem;
                text-align: left;
                width: max-content;
                background-color: #353535c9;
                border-radius: 6px;
                margin: 0 auto;
            }
            #turnIndicator {
                margin-top: 0;
            }
            button {
                border: none;
                background-color: #4D7EA8;
                color: white;
                padding: 5px;
                border-radius: 6px;
                cursor: pointer;
            }
            button:hover {
                background-color: #e68540 !important;
            }
            #computerMode {
                background-color: #e68540;
            }
            #soundToggle {
                background-color: #28a745;
                margin-left: 10px;
            }
            #soundToggle.muted {
                background-color: #dc3545;
            }
            img {
                width: 4rem;
                height: 4rem;
            }
            @media only screen and (max-width: 1050px) {
                #ui {
                    display: grid;
                    grid-template-columns: 100%;
                    grid-template-rows: auto auto;
                }
                .turnIndicatorContainer {
                    margin-bottom: calc(100vw / 18);
                    padding: calc(100vw / 18);
                    width: auto;
                }
                #boardColumn {
                    grid-row: 2;
                }
                #prefColumn {
                    grid-row: 1;
                }
                img {
                    width: calc(100vw / 9);
                    height: calc(100vw / 9);
                }
                .field {
                    width: calc(100vw / 9);
                    height: calc(100vw / 9);
                }
                .notationCol {
                    line-height: calc(100vw / 9);
                }
                .notationRow {
                    line-height: calc(100vw / 18);
                }
                #gameboard {
                    grid-template-columns: calc(100vw / 18) repeat(8, calc(100vw / 9));
                    grid-template-rows: repeat(8, calc(100vw / 9)) calc(100vw / 18) ;
                }
                #spacer {
                    padding: calc(100vw / 18) calc(100vw / 18) 0 0;
                    width: auto;
                }
                .marker {
                    line-height: calc(100vw / 9);
                    font-size: 70px;
                }
                button {
                    font-size: xx-large;
                    padding: 1rem;
                }
                #title {
                    font-size: 60px;
                }
            }
        </style>
    </head>
    <body>
        <h1 id="title">Chess Game</h1>
        <div id="ui">
			<div id="prefColumn">
                <div class="turnIndicatorContainer">
                    <h1 id="turnIndicator">
                        Whites turn
                    </h1>
        
                    <h1 id="moveCounter">Possible Moves: 20</h1>
        
                    <div class="settings">
                        <button onclick="reset()">New Game</button>
                        <button id="humanMode" onclick="setHumanMode()">VS Human</button>
                        <button id="computerMode" onclick="setComputerMode()">VS Computer</button>
                        <button id="soundToggle" onclick="toggleSound()">ðŸ”Š Sound ON</button>
                    </div>
                </div>
            </div>
            <div id="boardColumn">
                <div id="spacer">
                    <div id="gameboard">
                        <div class="notation notationCol row8">8</div>
                        <div class="notation notationCol row7">7</div>
                        <div class="notation notationCol row6">6</div>
                        <div class="notation notationCol row5">5</div>
                        <div class="notation notationCol row4">4</div>
                        <div class="notation notationCol row3">3</div>
                        <div class="notation notationCol row2">2</div>
                        <div class="notation notationCol row1">1</div>

                        <div class="notation notationRow colA">A</div>
                        <div class="notation notationRow colB">B</div>
                        <div class="notation notationRow colC">C</div>
                        <div class="notation notationRow colD">D</div>
                        <div class="notation notationRow colE">E</div>
                        <div class="notation notationRow colF">F</div>
                        <div class="notation notationRow colG">G</div>
                        <div class="notation notationRow colH">H</div>

                        <div id="1A" class="field dark row1 colA" ></div>
                        <div id="2A" class="field light row2 colA"></div>
                        <div id="3A" class="field dark row3 colA"></div>
                        <div id="4A" class="field light row4 colA"></div>
                        <div id="5A" class="field dark row5 colA"></div>
                        <div id="6A" class="field light row6 colA"></div>
                        <div id="7A" class="field dark row7 colA"></div>
                        <div id="8A" class="field light row8 colA"></div>
                        
                        <div id="1B" class="field light row1 colB"></div>
                        <div id="2B" class="field dark row2 colB"></div>
                        <div id="3B" class="field light row3 colB"></div>
                        <div id="4B" class="field dark row4 colB"></div>
                        <div id="5B" class="field light row5 colB"></div>
                        <div id="6B" class="field dark row6 colB"></div>
                        <div id="7B" class="field light row7 colB"></div>
                        <div id="8B" class="field dark row8 colB"></div>

                        <div id="1C" class="field dark row1 colC" ></div>
                        <div id="2C" class="field light row2 colC"></div>
                        <div id="3C" class="field dark row3 colC"></div>
                        <div id="4C" class="field light row4 colC"></div>
                        <div id="5C" class="field dark row5 colC"></div>
                        <div id="6C" class="field light row6 colC"></div>
                        <div id="7C" class="field dark row7 colC"></div>
                        <div id="8C" class="field light row8 colC"></div>

                        <div id="1D" class="field light row1 colD"></div>
                        <div id="2D" class="field dark row2 colD"></div>
                        <div id="3D" class="field light row3 colD"></div>
                        <div id="4D" class="field dark row4 colD"></div>
                        <div id="5D" class="field light row5 colD"></div>
                        <div id="6D" class="field dark row6 colD"></div>
                        <div id="7D" class="field light row7 colD"></div>
                        <div id="8D" class="field dark row8 colD"></div>
                    
                        <div id="1E" class="field dark row1 colE" ></div>
                        <div id="2E" class="field light row2 colE"></div>
                        <div id="3E" class="field dark row3 colE"></div>
                        <div id="4E" class="field light row4 colE"></div>
                        <div id="5E" class="field dark row5 colE"></div>
                        <div id="6E" class="field light row6 colE"></div>
                        <div id="7E" class="field dark row7 colE"></div>
                        <div id="8E" class="field light row8 colE"></div>

                        <div id="1F" class="field light row1 colF"></div>
                        <div id="2F" class="field dark row2 colF"></div>
                        <div id="3F" class="field light row3 colF"></div>
                        <div id="4F" class="field dark row4 colF"></div>
                        <div id="5F" class="field light row5 colF"></div>
                        <div id="6F" class="field dark row6 colF"></div>
                        <div id="7F" class="field light row7 colF"></div>
                        <div id="8F" class="field dark row8 colF"></div>

                        <div id="1G" class="field dark row1 colG" ></div>
                        <div id="2G" class="field light row2 colG"></div>
                        <div id="3G" class="field dark row3 colG"></div>
                        <div id="4G" class="field light row4 colG"></div>
                        <div id="5G" class="field dark row5 colG"></div>
                        <div id="6G" class="field light row6 colG"></div>
                        <div id="7G" class="field dark row7 colG"></div>
                        <div id="8G" class="field light row8 colG"></div>

                        <div id="1H" class="field light row1 colH"></div>
                        <div id="2H" class="field dark row2 colH"></div>
                        <div id="3H" class="field light row3 colH"></div>
                        <div id="4H" class="field dark row4 colH"></div>
                        <div id="5H" class="field light row5 colH"></div>
                        <div id="6H" class="field dark row6 colH"></div>
                        <div id="7H" class="field light row7 colH"></div>
                        <div id="8H" class="field dark row8 colH"></div>

                        <img id="wpA" onclick="showMoves(this)" class="piece row2 colA" src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/Chess_plt45.svg/45px-Chess_plt45.svg.png">
                        <img id="wpB" onclick="showMoves(this)" class="piece row2 colB" src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/Chess_plt45.svg/45px-Chess_plt45.svg.png">
                        <img id="wpC" onclick="showMoves(this)" class="piece row2 colC" src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/Chess_plt45.svg/45px-Chess_plt45.svg.png">
                        <img id="wpD" onclick="showMoves(this)" class="piece row2 colD" src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/Chess_plt45.svg/45px-Chess_plt45.svg.png">
                        <img id="wpE" onclick="showMoves(this)" class="piece row2 colE" src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/Chess_plt45.svg/45px-Chess_plt45.svg.png">
                        <img id="wpF" onclick="showMoves(this)" class="piece row2 colF" src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/Chess_plt45.svg/45px-Chess_plt45.svg.png">
                        <img id="wpG" onclick="showMoves(this)" class="piece row2 colG" src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/Chess_plt45.svg/45px-Chess_plt45.svg.png">
                        <img id="wpH" onclick="showMoves(this)" class="piece row2 colH" src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/45/Chess_plt45.svg/45px-Chess_plt45.svg.png">
                        
                        <img id="bpA" onclick="showMoves(this)" class="piece row7 colA" src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/Chess_pdt45.svg/45px-Chess_pdt45.svg.png">
                        <img id="bpB" onclick="showMoves(this)" class="piece row7 colB" src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/Chess_pdt45.svg/45px-Chess_pdt45.svg.png">
                        <img id="bpC" onclick="showMoves(this)" class="piece row7 colC" src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/Chess_pdt45.svg/45px-Chess_pdt45.svg.png">
                        <img id="bpD" onclick="showMoves(this)" class="piece row7 colD" src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/Chess_pdt45.svg/45px-Chess_pdt45.svg.png">
                        <img id="bpE" onclick="showMoves(this)" class="piece row7 colE" src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/Chess_pdt45.svg/45px-Chess_pdt45.svg.png">
                        <img id="bpF" onclick="showMoves(this)" class="piece row7 colF" src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/Chess_pdt45.svg/45px-Chess_pdt45.svg.png">
                        <img id="bpG" onclick="showMoves(this)" class="piece row7 colG" src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/Chess_pdt45.svg/45px-Chess_pdt45.svg.png">
                        <img id="bpH" onclick="showMoves(this)" class="piece row7 colH" src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/Chess_pdt45.svg/45px-Chess_pdt45.svg.png">
                        
                        <img id="wrA" onclick="showMoves(this)" class="piece row1 colA" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/Chess_rlt45.svg/45px-Chess_rlt45.svg.png">
                        <img id="wrH" onclick="showMoves(this)" class="piece row1 colH" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/72/Chess_rlt45.svg/45px-Chess_rlt45.svg.png">

                        <img id="brA" onclick="showMoves(this)" class="piece row8 colA" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Chess_rdt45.svg/45px-Chess_rdt45.svg.png">
                        <img id="brH" onclick="showMoves(this)" class="piece row8 colH" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/ff/Chess_rdt45.svg/45px-Chess_rdt45.svg.png">

                        <img id="wnB" onclick="showMoves(this)" class="piece row1 colB" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/70/Chess_nlt45.svg/45px-Chess_nlt45.svg.png">
                        <img id="wnG" onclick="showMoves(this)" class="piece row1 colG" src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/70/Chess_nlt45.svg/45px-Chess_nlt45.svg.png">

                        <img id="bnB" onclick="showMoves(this)" class="piece row8 colB" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ef/Chess_ndt45.svg/45px-Chess_ndt45.svg.png">
                        <img id="bnG" onclick="showMoves(this)" class="piece row8 colG" src="https://upload.wikimedia.org/wikipedia/commons/thumb/e/ef/Chess_ndt45.svg/45px-Chess_ndt45.svg.png">
                        
                        <img id="wbC" onclick="showMoves(this)" class="piece row1 colC" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b1/Chess_blt45.svg/45px-Chess_blt45.svg.png">
                        <img id="wbF" onclick="showMoves(this)" class="piece row1 colF" src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/b1/Chess_blt45.svg/45px-Chess_blt45.svg.png">

                        <img id="bbC" onclick="showMoves(this)" class="piece row8 colC" src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Chess_bdt45.svg/45px-Chess_bdt45.svg.png">
                        <img id="bbF" onclick="showMoves(this)" class="piece row8 colF" src="https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Chess_bdt45.svg/45px-Chess_bdt45.svg.png">
                        
                        <img id="wq" onclick="showMoves(this)" class="piece row1 colD" src="https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/Chess_qlt45.svg/45px-Chess_qlt45.svg.png">
                        <img id="bq" onclick="showMoves(this)" class="piece row8 colD" src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/47/Chess_qdt45.svg/45px-Chess_qdt45.svg.png">
                        
                        <img id="wk" onclick="showMoves(this)" class="piece row1 colE" src="https://upload.wikimedia.org/wikipedia/commons/thumb/4/42/Chess_klt45.svg/45px-Chess_klt45.svg.png">
                        <img id="bk" onclick="showMoves(this)" class="piece row8 colE" src="https://upload.wikimedia.org/wikipedia/commons/thumb/f/f0/Chess_kdt45.svg/45px-Chess_kdt45.svg.png">
                    </div>                 
                </div>
            </div>
         
        </div>
    
        <script>
            // Audio system
            let audioContext;
            let soundEnabled = true;

            // Initialize audio context
            function initAudio() {
                if (!audioContext) {
                    audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }
            }

            // Generate sound using Web Audio API
            function playSound(frequency, duration, type = 'sine', volume = 0.1) {
                if (!soundEnabled) return;
                
                try {
                    initAudio();
                    
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();
                    
                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);
                    
                    oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);
                    oscillator.type = type;
                    
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(volume, audioContext.currentTime + 0.01);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                } catch (e) {
                    console.warn('Audio playback failed:', e);
                }
            }

            // Sound effects
            function playSounds() {
                return {
                    move: () => playSound(220, 0.1, 'sine', 0.1),
                    capture: () => {
                        playSound(440, 0.15, 'sawtooth', 0.15);
                        setTimeout(() => playSound(330, 0.1, 'triangle', 0.1), 50);
                    },
                    check: () => {
                        playSound(880, 0.2, 'square', 0.2);
                        setTimeout(() => playSound(660, 0.15, 'square', 0.15), 100);
                    },
                    castle: () => {
                        playSound(330, 0.2, 'sine', 0.15);
                        setTimeout(() => playSound(440, 0.2, 'sine', 0.15), 100);
                    },
                    promotion: () => {
                        for (let i = 0; i < 4; i++) {
                            setTimeout(() => playSound(440 + i * 110, 0.1, 'triangle', 0.1), i * 50);
                        }
                    },
                    gameEnd: () => {
                        const notes = [523, 587, 659, 698, 784, 880];
                        notes.forEach((note, i) => {
                            setTimeout(() => playSound(note, 0.3, 'sine', 0.15), i * 100);
                        });
                    },
                    select: () => playSound(880, 0.05, 'sine', 0.05)
                };
            }

            const sounds = playSounds();

            function toggleSound() {
                soundEnabled = !soundEnabled;
                const button = document.getElementById('soundToggle');
                if (soundEnabled) {
                    button.textContent = 'ðŸ”Š Sound ON';
                    button.classList.remove('muted');
                } else {
                    button.textContent = 'ðŸ”‡ Sound OFF';
                    button.classList.add('muted');
                }
            }

            // Chess game logic
            let board;
            let onPieceFocus = false;
            let fieldOnFocus;
            let pieceOnFocus;
            let whitesTurn = true;
            let whitePawnSwapCounter = "I";
            let blackPawnSwapCounter = "I";
            let enPassantPawn = null;

            let whiteCanCastle = true;
            let blackCanCastle = true;
            let wKRookMoved = false;
            let bKRookMoved = false;
            let wQRookMoved = false;
            let bQRookMoved = false;

            let chessCheck = true;
            let markedMoves = [];

            function setupGame() {
                board = [["wrA", "wnB", "wbC", "wq", "wk", "wbF", "wnG","wrH"],
                            ["wpA", "wpB", "wpC", "wpD", "wpE", "wpF", "wpG","wpH"],
                            ["", "", "", "", "", "", "",""],
                            ["", "", "", "", "", "", "",""],
                            ["", "", "", "", "", "", "",""],
                            ["", "", "", "", "", "", "",""],
                            ["bpA", "bpB", "bpC", "bpD","bpE","bpF", "bpG" ,"bpH"],
                            ["brA", "bnB", "bbC", "bq","bk","bbF", "bnG" ,"brH"]
                        ];
            }

            function reset() {
                location.reload();
            }

            let playMode = "c";
            let humansColor = "w";

            function setHumanMode() {
                let humanButton = document.getElementById("humanMode");
                let comButton = document.getElementById("computerMode");

                if(playMode != "h") {
                    playMode = "h";
                    humanButton.style.backgroundColor = "#e68540";
                    comButton.style.backgroundColor = "#4D7EA8";
                } else {
                    alert("You already play Human vs Human");
                }
            }

            function setComputerMode() {
                let humanButton = document.getElementById("humanMode");
                let comButton = document.getElementById("computerMode");

                if(playMode != "c") {
                    playMode = "c";

                    if(whitesTurn) {
                        humansColor = "w";
                    } else {
                        humansColor = "b";
                    }

                    humanButton.style.backgroundColor = "#4D7EA8";
                    comButton.style.backgroundColor = "#e68540";
                } else {
                    alert("You already play Human vs Computer");
                }
            }

            function movePiece(newField) {
                newField = newField.parentElement;

                if(markedMoves.includes(newField.id)) {
                    let newFieldPosition = fieldIdToBoardPosition(newField.id);
                    let wasCapture = false;
                    let wasCastle = false;
                    let wasPromotion = false;

                    if(newField.classList.contains("catch")) {
                        let catchedPiece = board[newFieldPosition.row][newFieldPosition.col];
                        let catchedPieceEm = document.getElementById(catchedPiece);
                        catchedPieceEm.remove();
                        wasCapture = true;
                    }

                    let pieceRow = pieceOnFocus.classList[1];
                    let pieceCol = pieceOnFocus.classList[2];

                    pieceOnFocus.classList.remove(pieceRow);
                    pieceOnFocus.classList.remove(pieceCol);

                    let newPieceRow = newField.classList[2];
                    let newPieceCol = newField.classList[3];

                    pieceOnFocus.classList.add(newPieceRow);
                    pieceOnFocus.classList.add(newPieceCol);

                    let piecePositionOnBoard = givePosition(board, pieceOnFocus.id);

                    if(getPieceType(pieceOnFocus.id) == "wp" && newField.id.startsWith("8")) {
                        pieceOnFocus.id = "wq" + whitePawnSwapCounter;
                        pieceOnFocus.src = "https://upload.wikimedia.org/wikipedia/commons/thumb/1/15/Chess_qlt45.svg/45px-Chess_qlt45.svg.png";
                        whitePawnSwapCounter = whitePawnSwapCounter + "I";
                        wasPromotion = true;

                    } else if(getPieceType(pieceOnFocus.id) == "bp" && newField.id.startsWith("1")) {
                        pieceOnFocus.id = "bq" + blackPawnSwapCounter;
                        pieceOnFocus.src = "https://upload.wikimedia.org/wikipedia/commons/thumb/4/47/Chess_qdt45.svg/45px-Chess_qdt45.svg.png";
                        blackPawnSwapCounter = blackPawnSwapCounter + "I";
                        wasPromotion = true;
                    }

                    // Handle castling
                    if(pieceOnFocus.id === "wk" && whiteCanCastle) {
                        if(newField.id === "1G") {
                            let wKRook = document.getElementById("wrH");
                            let pieceRow = wKRook.classList[1];
                            let pieceCol = wKRook.classList[2];
                            wKRook.classList.remove(pieceRow);
                            wKRook.classList.remove(pieceCol);
                            wKRook.classList.add("row1");
                            wKRook.classList.add("colF");
                            board[0][5] = "wrH";
                            board[0][7] = "";
                            wasCastle = true;

                        } else if(newField.id === "1C") {
                            let wQRook = document.getElementById("wrA");
                            let pieceRow = wQRook.classList[1];
                            let pieceCol = wQRook.classList[2];
                            wQRook.classList.remove(pieceRow);
                            wQRook.classList.remove(pieceCol);
                            wQRook.classList.add("row1");
                            wQRook.classList.add("colD");
                            board[0][3] = "wrA";
                            board[0][0] = "";
                            wasCastle = true;
                        }
                    } else if(pieceOnFocus.id === "bk" && blackCanCastle) {
                        if(newField.id === "8G") {
                            let bKRook = document.getElementById("brH");
                            let pieceRow = bKRook.classList[1];
                            let pieceCol = bKRook.classList[2];
                            bKRook.classList.remove(pieceRow);
                            bKRook.classList.remove(pieceCol);
                            bKRook.classList.add("row8");
                            bKRook.classList.add("colF");
                            board[7][5] = "brH";
                            board[7][7] = "";
                            wasCastle = true;

                        } else if(newField.id === "8C") {
                            let bQRook = document.getElementById("brA");
                            let pieceRow = bQRook.classList[1];
                            let pieceCol = bQRook.classList[2];
                            bQRook.classList.remove(pieceRow);
                            bQRook.classList.remove(pieceCol);
                            bQRook.classList.add("row8");
                            bQRook.classList.add("colD");
                            board[7][3] = "brA";
                            board[7][0] = "";
                            wasCastle = true;
                        }
                    }

                    // Update castling abilities
                    switch(pieceOnFocus.id) {
                        case "wrA":
                            wQRookMoved = true;
                            break;
                        case "wrH":
                            wKRookMoved = true;
                            break;
                        case "brA":
                            bQRookMoved = true;
                            break;
                        case "brH":
                            bKRookMoved = true;
                            break;
                        case "bk":
                            blackCanCastle = false;
                            break;
                        case "wk":
                            whiteCanCastle = false;
                            break;
                    }

                    if(wQRookMoved && wKRookMoved && whiteCanCastle) {
                        whiteCanCastle = false;
                    } else if(bKRookMoved && bQRookMoved && blackCanCastle){
                        blackCanCastle = false;
                    }

                    // Handle en passant capture
                    if(enPassantPawn) {
                        if(pieceOnFocus.id.indexOf('wp') === 0) {
                            if(newFieldPosition.col === enPassantPawn.col && newFieldPosition.row === enPassantPawn.row + 1) {
                                let catchedPawn = document.getElementById(board[enPassantPawn.row][enPassantPawn.col]);
                                catchedPawn.remove();
                                board[enPassantPawn.row][enPassantPawn.col] = "";
                                wasCapture = true;
                            }
                        } else if(pieceOnFocus.id.indexOf('bp') === 0) {
                            if(newFieldPosition.col === enPassantPawn.col && newFieldPosition.row === enPassantPawn.row - 1) {
                                let catchedPawn = document.getElementById(board[enPassantPawn.row][enPassantPawn.col]);
                                catchedPawn.remove();
                                board[enPassantPawn.row][enPassantPawn.col] = "";
                                wasCapture = true;
                            }
                        }
                    }
                    
                    // Update en passant pawn
                    if(pieceOnFocus.id.indexOf('p') === 1 && Math.abs(piecePositionOnBoard.row - newFieldPosition.row) === 2) {
                        enPassantPawn = newFieldPosition;
                    } else {
                        enPassantPawn = null;
                    }
                    
                    // Update board
                    board[newFieldPosition.row][newFieldPosition.col] = pieceOnFocus.id;
                    board[piecePositionOnBoard.row][piecePositionOnBoard.col] = "";

                    deleteMarker();
                    unmarkPiece();

                    // Play appropriate sound
                    if (wasPromotion) {
                        sounds.promotion();
                    } else if (wasCastle) {
                        sounds.castle();
                    } else if (wasCapture) {
                        sounds.capture();
                    } else {
                        sounds.move();
                    }

                    changeTurn();

                    if(playMode === "c") {
                        if(whitesTurn && humansColor === "b") {
                            makeComputerMove("w");
                        }
                        if(!whitesTurn && humansColor === "w") {
                            makeComputerMove("b");
                        }
                    }
                } else {
                    console.log("nope");
                }
            }

            function makeComputerMove(computerColor) {
                let randomMarker;
                let pieces = getAllActivePiecesOfPlayer(computerColor, board);

                while(randomMarker == null && getAllPossibleMovesOfPlayer(computerColor, board) != 0) {
                    let randomPiece = pieces[Math.floor(Math.random() * pieces.length)];
                    const index = pieces.indexOf(randomPiece);
                    if (index > -1) {
                        pieces.splice(index, 1);
                    }

                    document.getElementById(randomPiece).click();
                    let allMarkers = document.getElementsByClassName("marker");

                    if(allMarkers.length === 0) {
                        deleteMarker();
                        unmarkPiece();
                    } else {
                        randomMarker = allMarkers[Math.floor(Math.random() * allMarkers.length)];
                    }
                }

                if(getAllPossibleMovesOfPlayer(computerColor, board) != 0) {
                    setTimeout(function(){ 
                        randomMarker.click();
                    }, 1500);
                }
            }

            function changeTurn() {
                let em = document.getElementById("turnIndicator");
                let moveCounter = document.getElementById("moveCounter");
                let moveAmount;

                if(whitesTurn) {
                    whitesTurn = false;
                    em.innerHTML = "Blacks Turn";
                    moveAmount = getAllPossibleMovesOfPlayer("b", board).length;
                } else {
                    whitesTurn = true;
                    em.innerHTML = "Whites Turn"
                    moveAmount = getAllPossibleMovesOfPlayer("w", board).length;
                }

                // Check for check
                if(whitesTurn && checkIfPlayerIsInChess("w", board)) {
                    sounds.check();
                } else if(!whitesTurn && checkIfPlayerIsInChess("b", board)) {
                    sounds.check();
                }

                if(moveAmount === 0) {
                    sounds.gameEnd();
                    if(whitesTurn && checkIfPlayerIsInChess("w", board)) {
                        moveCounter.innerHTML = "Check Mate, Black Wins!";
                    } else if (!whitesTurn && checkIfPlayerIsInChess("b", board)) {
                        moveCounter.innerHTML = "Check Mate, White Wins!";
                    } else {
                        moveCounter.innerHTML = "Stale Mate...Draw!";
                    }
                } else {
                    moveCounter.innerHTML = "Possible Moves: " + moveAmount;
                }
            }

            function showMoves(element) {
                let emId = element.id;
                let activeBoard = board;

                if((emId.startsWith("w") && whitesTurn) || (emId.startsWith("b") && !whitesTurn)) {
                    if(pieceOnFocus) {
                        deleteMarker();
                        unmarkPiece();
                    } else {
                        sounds.select();
                        pieceOnFocus = element;
                        let piecePosition = givePosition(activeBoard, element.id);
                        let pieceType = getPieceType(element.id);
                        let legalMoves = getLegalMoves(piecePosition, pieceType, activeBoard);
                        markPieceOnFocus(piecePosition);
                        markLegalMoves(legalMoves);
                    }
                }
            }

            // All the remaining chess logic functions follow...
            function checkIfPieceIsOnField(position, activeBoard) {
                if(activeBoard[position.row][position.col]) {
                    return true;
                } else {
                    return false;
                }
            }

            function getColorOfPieceAtPosition(position, board) {
                let piece = board[position.row][position.col];
                return piece.charAt(0);
            }

            function makeMoveAndCheckIfChess(piecePosition, newPosition, playerColor) {
                let tempBoard = [["", "", "", "", "", "", "",""],
                    ["", "", "", "", "", "", "",""],
                    ["", "", "", "", "", "", "",""],
                    ["", "", "", "", "", "", "",""],
                    ["", "", "", "", "", "", "",""],
                    ["", "", "", "", "", "", "",""],
                    ["", "", "", "","","", "" ,""],
                    ["", "", "", "","","", "" ,""]
                ];

                for(let i = 0; i < board.length; i++) {
                    for(let j = 0; j < board[i].length; j++) {
                        tempBoard[i][j] = board[i][j];
                    }
                }

                tempBoard[newPosition.row][newPosition.col] = tempBoard[piecePosition.row][piecePosition.col];
                tempBoard[piecePosition.row][piecePosition.col] = "";
                return checkIfPlayerIsInChess(playerColor, tempBoard);
            }

            function makeMoveAndReturnNewBoard(piecePosition, newPosition) {
                let tempBoard = [["", "", "", "", "", "", "",""],
                    ["", "", "", "", "", "", "",""],
                    ["", "", "", "", "", "", "",""],
                    ["", "", "", "", "", "", "",""],
                    ["", "", "", "", "", "", "",""],
                    ["", "", "", "", "", "", "",""],
                    ["", "", "", "","","", "" ,""],
                    ["", "", "", "","","", "" ,""]
                ];

                for(let i = 0; i < board.length; i++) {
                    for(let j = 0; j < board[i].length; j++) {
                        tempBoard[i][j] = board[i][j];
                    }
                }

                tempBoard[newPosition.row][newPosition.col] = tempBoard[piecePosition.row][piecePosition.col];
                tempBoard[piecePosition.row][piecePosition.col] = "";
                return tempBoard;
            }

            function getLegalMoves(piecePosition, pieceType, activeBoard) {
                let playerColor = getColorOfPieceAtPosition(piecePosition, activeBoard);
                let legalMoves = [];
                let position;

                switch(pieceType) {
                    case "wp":
                        if(piecePosition.row === 1) {
                            // diagonal catches
                            for(let k = -1; k < 2; k = k+2) {
                                position = {
                                    row: piecePosition.row+1,
                                    col: piecePosition.col+k
                                };

                                if(checkIfPieceIsOnField(position, activeBoard)) {
                                    if(getColorOfPieceAtPosition(position, activeBoard) != playerColor) {
                                        if(chessCheck) {
                                            if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                                continue;
                                            }
                                        }
                                        legalMoves.push(position);
                                    }
                                } else {
                                    continue;
                                }
                            }

                            for(let i = 1; i <= 2; i++) {
                                position = {
                                    row: piecePosition.row+i,
                                    col: piecePosition.col
                                };

                                if(checkIfPieceIsOnField(position, activeBoard)) {
                                    break;
                                } else {
                                    if(chessCheck) {
                                        if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                            continue;
                                        }
                                    }
                                    legalMoves.push(position);
                                }
                            }

                        } else {
                            if(piecePosition.row+1 < 8) {
                                // check if a piece can be catched diagonal
                                for(let k = -1; k < 2; k = k+2) {
                                    position = {
                                        row: piecePosition.row+1,
                                        col: piecePosition.col+k
                                    };

                                    if(checkIfPieceIsOnField(position, activeBoard)) {
                                        if(getColorOfPieceAtPosition(position, activeBoard) != playerColor) {
                                            if(chessCheck) {
                                                if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                                    continue;
                                                }
                                            }
                                            legalMoves.push(position);
                                        }
                                    } else if (enPassantPawn){
                                        if(position.col === enPassantPawn.col && position.row === enPassantPawn.row + 1) {
                                            if(chessCheck) {
                                                if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                                    continue;
                                                }
                                            }
                                            legalMoves.push(position);
                                        }
                                    } else {
                                        continue;
                                    }
                                }
                                
                                position = {
                                    row: piecePosition.row+1,
                                    col: piecePosition.col
                                };

                                if(!checkIfPieceIsOnField(position, activeBoard)) {
                                    if(chessCheck) {
                                        if(!makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                            legalMoves.push(position);
                                        }
                                    }
                                }
                            }   
                        }
                        break;

                    case "bp":
                        if(piecePosition.row === 6) {
                            // diagonal catches
                            for(let k = -1; k < 2; k = k+2) {
                                position = {
                                    row: piecePosition.row-1,
                                    col: piecePosition.col+k
                                };

                                if(checkIfPieceIsOnField(position, activeBoard)) {
                                    if(getColorOfPieceAtPosition(position, activeBoard) != playerColor) {
                                        if(chessCheck) {
                                            if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                                continue;
                                            }
                                        }
                                        legalMoves.push(position);
                                    }
                                } else {
                                    continue;
                                }
                            }

                            for(let i = 1; i <= 2; i++) {
                                position = {
                                    row: piecePosition.row-i,
                                    col: piecePosition.col
                                };

                                if(checkIfPieceIsOnField(position, activeBoard)) {
                                    break;
                                } else {
                                    if(chessCheck) {
                                        if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                            continue;
                                        }
                                    }
                                    legalMoves.push(position);
                                }
                            }

                        } else {
                            if(piecePosition.row-1 >= 0) {
                                // check if a piece can be catched diagonal
                                for(let k = -1; k < 2; k = k+2) {
                                    position = {
                                        row: piecePosition.row-1,
                                        col: piecePosition.col+k
                                    };

                                    if(checkIfPieceIsOnField(position, activeBoard)) {
                                        if(getColorOfPieceAtPosition(position, activeBoard) != playerColor) {
                                            if(chessCheck) {
                                                if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                                    continue;
                                                }
                                            }
                                            legalMoves.push(position);
                                        }
                                    } else if (enPassantPawn){
                                        if(position.col === enPassantPawn.col && position.row === enPassantPawn.row - 1) {
                                            if(chessCheck) {
                                                if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                                    continue;
                                                }
                                            }
                                            legalMoves.push(position);
                                        }
                                    } else {
                                        continue;
                                    }
                                }
                                
                                position = {
                                    row: piecePosition.row-1,
                                    col: piecePosition.col
                                };

                                if(!checkIfPieceIsOnField(position, activeBoard)) {
                                    if(chessCheck) {
                                        if(!makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                            legalMoves.push(position);
                                        }
                                    }
                                }
                            }   
                        }
                        break;

                    case "n":
                        for(let j = -1; j < 2; j++) {
                            if(piecePosition.row+2 < 8) {
                                if(j != 0 && piecePosition.col+j >= 0 && piecePosition.col+j < 8) {
                                    position = {
                                        row: piecePosition.row+2,
                                        col: piecePosition.col+j
                                    };
                                    
                                    if(getColorOfPieceAtPosition(position, activeBoard) != playerColor) {
                                        if(chessCheck) {
                                            if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                                continue;
                                            }
                                        }
                                        legalMoves.push(position);
                                    }
                                }
                            }    
                        }

                        for(let j = -1; j < 2; j++) {
                            if(piecePosition.row-2 >= 0) {
                                if(j != 0 && piecePosition.col+j >= 0 && piecePosition.col+j < 8) {
                                    position = {
                                        row: piecePosition.row-2,
                                        col: piecePosition.col+j
                                    };

                                    if(getColorOfPieceAtPosition(position, activeBoard) != playerColor) {
                                        if(chessCheck) {
                                            if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                                continue;
                                            }
                                        }
                                        legalMoves.push(position);
                                    }
                                }
                            }   
                        }

                        for(let j = -1; j < 2; j++) {
                            if(piecePosition.col+2 < 8) {
                                if(j != 0 && piecePosition.row+j >= 0 && piecePosition.row+j < 8) {
                                    position = {
                                        row: piecePosition.row+j,
                                        col: piecePosition.col+2,
                                    };

                                    if(getColorOfPieceAtPosition(position, activeBoard) != playerColor) {
                                        if(chessCheck) {
                                            if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                                continue;
                                            }
                                        }
                                        legalMoves.push(position);
                                    }
                                }
                            }   
                        }

                        for(let j = -1; j < 2; j++) {
                            if(piecePosition.col-2 >= 0) {
                                if(j != 0 && piecePosition.row+j >= 0 && piecePosition.row+j < 8) {
                                    position = {
                                        row: piecePosition.row+j,
                                        col: piecePosition.col-2,
                                    };

                                    if(getColorOfPieceAtPosition(position, activeBoard) != playerColor) {
                                        if(chessCheck) {
                                            if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                                continue;
                                            }
                                        }
                                        legalMoves.push(position);
                                    }
                                }
                            }   
                        }
                        break;
                    
                    case "b":
                        for(let j = 1; j < 8; j++) {
                            if(piecePosition.row+j < 8 && piecePosition.col+j < 8) {
                                position = {
                                    row: piecePosition.row+j,
                                    col: piecePosition.col+j
                                }

                                let clr = getColorOfPieceAtPosition(position, activeBoard);

                                if(clr != playerColor) {
                                    if(chessCheck) {
                                        if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                            if(clr) {
                                                break;
                                            } else {
                                                continue;
                                            }
                                        }
                                    }

                                    legalMoves.push(position);

                                    if(clr) {
                                        break;
                                    }
                                }  else {
                                    break;
                                }

                            } else {
                                break;
                            }   
                        }    

                        for(let j = 1; j < 8; j++) {
                            if(piecePosition.row+j < 8 && piecePosition.col-j >= 0) {
                                position = {
                                    row: piecePosition.row+j,
                                    col: piecePosition.col-j
                                }

                                let clr = getColorOfPieceAtPosition(position, activeBoard);

                                if(clr != playerColor) {
                                    if(chessCheck) {
                                        if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                            if(clr) {
                                                break;
                                            } else {
                                                continue;
                                            }
                                        }
                                    }

                                    legalMoves.push(position);

                                    if(clr) {
                                        break;
                                    }
                                }  else {
                                    break;
                                }

                            } else {
                                break;
                            }   
                        }

                        for(let j = 1; j < 8; j++) {
                            if(piecePosition.row-j >= 0 && piecePosition.col-j >= 0) {
                                position = {
                                    row: piecePosition.row-j,
                                    col: piecePosition.col-j
                                }

                                let clr = getColorOfPieceAtPosition(position, activeBoard);

                                if(clr != playerColor) {
                                    if(chessCheck) {
                                        if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                            if(clr) {
                                                break;
                                            } else {
                                                continue;
                                            }
                                        }
                                    }

                                    legalMoves.push(position);

                                    if(clr) {
                                        break;
                                    }
                                }  else {
                                    break;
                                }

                            } else {
                                break;
                            }   
                        }

                        for(let j = 1; j < 8; j++) {
                            if(piecePosition.row-j >= 0 && piecePosition.col+j < 8) {
                                position = {
                                    row: piecePosition.row-j,
                                    col: piecePosition.col+j
                                }

                                let clr = getColorOfPieceAtPosition(position, activeBoard);

                                if(clr != playerColor) {
                                    if(chessCheck) {
                                        if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                            if(clr) {
                                                break;
                                            } else {
                                                continue;
                                            }
                                        }
                                    }

                                    legalMoves.push(position);

                                    if(clr) {
                                        break;
                                    }
                                } else {
                                    break;
                                }

                            } else {
                                break;
                            }   
                        }
                        break;

                    case "r":
                        for(let j = piecePosition.row+1; j < 8; j++) {  
                            position = {
                                row: j,
                                col: piecePosition.col
                            }

                            let clr = getColorOfPieceAtPosition(position, activeBoard);

                            if(clr != playerColor) {
                                if(chessCheck) {
                                    if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                        if(clr) {
                                            break;
                                        } else {
                                            continue;
                                        }
                                    }
                                }

                                legalMoves.push(position);

                                if(clr) {
                                    break;
                                }
                            } else {
                                break;
                            } 
                        }

                        for(let j = piecePosition.row-1; j >= 0; j--) {
                            position = {
                                row: j,
                                col: piecePosition.col
                            }

                            let clr = getColorOfPieceAtPosition(position, activeBoard);

                            if(clr != playerColor) {
                                if(chessCheck) {
                                    if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                        if(clr) {
                                            break;
                                        } else {
                                            continue;
                                        }
                                    }
                                }

                                legalMoves.push(position);

                                if(clr) {
                                    break;
                                }
                            } else {
                                break;
                            }
                        }

                        for(let j = piecePosition.col+1; j < 8; j++) {
                            position = {
                                row: piecePosition.row,
                                col: j
                            }

                            let clr = getColorOfPieceAtPosition(position, activeBoard);

                            if(clr != playerColor) {
                                if(chessCheck) {
                                    if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                        if(clr) {
                                            break;
                                        } else {
                                            continue;
                                        }
                                    }
                                }

                                legalMoves.push(position);

                                if(clr) {
                                    break;
                                }
                            } else {
                                break;
                            }
                        }

                        for(let j = piecePosition.col-1; j >= 0; j--) {
                            position = {
                                row: piecePosition.row,
                                col: j
                            }

                            let clr = getColorOfPieceAtPosition(position, activeBoard);

                            if(clr != playerColor) {
                                if(chessCheck) {
                                    if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                        if(clr) {
                                            break;
                                        } else {
                                            continue;
                                        }
                                    }
                                }

                                legalMoves.push(position);

                                if(clr) {
                                    break;
                                }
                            } else {
                                break;
                            }
                        }
                        break;

                    case "q":
                        // Rook movement
                        for(let j = piecePosition.row+1; j < 8; j++) {  
                            position = {
                                row: j,
                                col: piecePosition.col
                            }

                            let clr = getColorOfPieceAtPosition(position, activeBoard);

                            if(clr != playerColor) {
                                if(chessCheck) {
                                    if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                        if(clr) {
                                            break;
                                        } else {
                                            continue;
                                        }
                                    }
                                }

                                legalMoves.push(position);

                                if(clr) {
                                    break;
                                }
                            } else {
                                break;
                            } 
                        }

                        for(let j = piecePosition.row-1; j >= 0; j--) {
                            position = {
                                row: j,
                                col: piecePosition.col
                            }

                            let clr = getColorOfPieceAtPosition(position, activeBoard);

                            if(clr != playerColor) {
                                if(chessCheck) {
                                    if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                        if(clr) {
                                            break;
                                        } else {
                                            continue;
                                        }
                                    }
                                }

                                legalMoves.push(position);

                                if(clr) {
                                    break;
                                }
                            } else {
                                break;
                            }
                        }

                        for(let j = piecePosition.col+1; j < 8; j++) {
                            position = {
                                row: piecePosition.row,
                                col: j
                            }

                            let clr = getColorOfPieceAtPosition(position, activeBoard);

                            if(clr != playerColor) {
                                if(chessCheck) {
                                    if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                        if(clr) {
                                            break;
                                        } else {
                                            continue;
                                        }
                                    }
                                }

                                legalMoves.push(position);

                                if(clr) {
                                    break;
                                }
                            } else {
                                break;
                            }
                        }

                        for(let j = piecePosition.col-1; j >= 0; j--) {
                            position = {
                                row: piecePosition.row,
                                col: j
                            }

                            let clr = getColorOfPieceAtPosition(position, activeBoard);

                            if(clr != playerColor) {
                                if(chessCheck) {
                                    if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                        if(clr) {
                                            break;
                                        } else {
                                            continue;
                                        }
                                    }
                                }

                                legalMoves.push(position);

                                if(clr) {
                                    break;
                                }
                            } else {
                                break;
                            }
                        }

                        // Bishop movement
                        for(let j = 1; j < 8; j++) {
                            if(piecePosition.row+j < 8 && piecePosition.col+j < 8) {
                                position = {
                                    row: piecePosition.row+j,
                                    col: piecePosition.col+j
                                }

                                let clr = getColorOfPieceAtPosition(position, activeBoard);

                                if(clr != playerColor) {
                                    if(chessCheck) {
                                        if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                            if(clr) {
                                                break;
                                            } else {
                                                continue;
                                            }
                                        }
                                    }

                                    legalMoves.push(position);

                                    if(clr) {
                                        break;
                                    }
                                }  else {
                                    break;
                                }

                            } else {
                                break;
                            }   
                        }    

                        for(let j = 1; j < 8; j++) {
                            if(piecePosition.row+j < 8 && piecePosition.col-j >= 0) {
                                position = {
                                    row: piecePosition.row+j,
                                    col: piecePosition.col-j
                                }

                                let clr = getColorOfPieceAtPosition(position, activeBoard);

                                if(clr != playerColor) {
                                    if(chessCheck) {
                                        if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                            if(clr) {
                                                break;
                                            } else {
                                                continue;
                                            }
                                        }
                                    }

                                    legalMoves.push(position);

                                    if(clr) {
                                        break;
                                    }
                                }  else {
                                    break;
                                }

                            } else {
                                break;
                            }   
                        }

                        for(let j = 1; j < 8; j++) {
                            if(piecePosition.row-j >= 0 && piecePosition.col-j >= 0) {
                                position = {
                                    row: piecePosition.row-j,
                                    col: piecePosition.col-j
                                }

                                let clr = getColorOfPieceAtPosition(position, activeBoard);

                                if(clr != playerColor) {
                                    if(chessCheck) {
                                        if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                            if(clr) {
                                                break;
                                            } else {
                                                continue;
                                            }
                                        }
                                    }

                                    legalMoves.push(position);

                                    if(clr) {
                                        break;
                                    }
                                }  else {
                                    break;
                                }

                            } else {
                                break;
                            }   
                        }

                        for(let j = 1; j < 8; j++) {
                            if(piecePosition.row-j >= 0 && piecePosition.col+j < 8) {
                                position = {
                                    row: piecePosition.row-j,
                                    col: piecePosition.col+j
                                }

                                let clr = getColorOfPieceAtPosition(position, activeBoard);

                                if(clr != playerColor) {
                                    if(chessCheck) {
                                        if(makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                            if(clr) {
                                                break;
                                            } else {
                                                continue;
                                            }
                                        }
                                    }

                                    legalMoves.push(position);

                                    if(clr) {
                                        break;
                                    }
                                } else {
                                    break;
                                }

                            } else {
                                break;
                            }   
                        }
                        break;

                    case "k":
                        // White castling moves
                        if(playerColor === "w" && whiteCanCastle) {
                            if(!wKRookMoved && activeBoard[0][5] === "" && activeBoard[0][6] === "") {
                                position = {
                                    row: piecePosition.row,
                                    col : piecePosition.col+2
                                };

                                let illegalMove = false;
                                let opponentMoves = getAllPossibleMovesOfPlayer("b", board);

                                for(let move of opponentMoves) {
                                    if(move.row === 0 && move.col === 4) {
                                        illegalMove = true;
                                    }
                                }

                                let tempPosition = {
                                    row: piecePosition.row,
                                    col: piecePosition.col+1
                                };

                                let boardAfterTempMove = makeMoveAndReturnNewBoard(piecePosition, tempPosition);
                                let opponentMovesAfterTempMove = getAllPossibleMovesOfPlayer("b", boardAfterTempMove);

                                for(let move of opponentMovesAfterTempMove) {
                                    if(move.row === 0 && move.col === 5) {
                                        illegalMove = true;
                                    }
                                }

                                let boardAfterMove = makeMoveAndReturnNewBoard(piecePosition, position);
                                let opponentMovesAfterMove = getAllPossibleMovesOfPlayer("b", boardAfterMove);

                                for(let move of opponentMovesAfterMove) {
                                    if(move.row === 0 && move.col === 6) {
                                        illegalMove = true;
                                    }
                                }   

                                if(!illegalMove) {
                                    legalMoves.push(position);
                                }
                            }

                            if(!wQRookMoved && activeBoard[0][1] === "" && activeBoard[0][2] === "" && activeBoard[0][3] === "") {
                                position = {
                                    row: piecePosition.row,
                                    col : piecePosition.col-2
                                };

                                let illegalMove = false;
                                let opponentMoves = getAllPossibleMovesOfPlayer("b", board);

                                for(let move of opponentMoves) {
                                    if(move.row === 0 && move.col === 4) {
                                        illegalMove = true;
                                    }
                                }

                                let tempPosition = {
                                    row: piecePosition.row,
                                    col: piecePosition.col-1
                                };

                                let boardAfterTempMove = makeMoveAndReturnNewBoard(piecePosition, tempPosition);
                                let opponentMovesAfterTempMove = getAllPossibleMovesOfPlayer("b", boardAfterTempMove);

                                for(let move of opponentMovesAfterTempMove) {
                                    if(move.row === 0 && move.col === 3) {
                                        illegalMove = true;
                                    }
                                }

                                let boardAfterMove = makeMoveAndReturnNewBoard(piecePosition, position);
                                let opponentMovesAfterMove = getAllPossibleMovesOfPlayer("b", boardAfterMove);

                                for(let move of opponentMovesAfterMove) {
                                    if(move.row === 0 && move.col === 2) {
                                        illegalMove = true;
                                    }
                                }   

                                if(!illegalMove) {
                                    legalMoves.push(position);
                                }
                            }
                        } else if(playerColor === "b" && blackCanCastle) {
                            if(!bKRookMoved && activeBoard[7][5] === "" && activeBoard[7][6] === "") {
                                position = {
                                    row: piecePosition.row,
                                    col : piecePosition.col+2
                                };

                                let illegalMove = false;
                                let opponentMoves = getAllPossibleMovesOfPlayer("w", board);

                                for(let move of opponentMoves) {
                                    if(move.row === 7 && move.col === 4) {
                                        illegalMove = true;
                                    }
                                }

                                let tempPosition = {
                                    row: piecePosition.row,
                                    col: piecePosition.col+1
                                };

                                let boardAfterTempMove = makeMoveAndReturnNewBoard(piecePosition, tempPosition);
                                let opponentMovesAfterTempMove = getAllPossibleMovesOfPlayer("w", boardAfterTempMove);

                                for(let move of opponentMovesAfterTempMove) {
                                    if(move.row === 7 && move.col === 5) {
                                        illegalMove = true;
                                    }
                                }

                                let boardAfterMove = makeMoveAndReturnNewBoard(piecePosition, position);
                                let opponentMovesAfterMove = getAllPossibleMovesOfPlayer("w", boardAfterMove);

                                for(let move of opponentMovesAfterMove) {
                                    if(move.row === 7 && move.col === 6) {
                                        illegalMove = true;
                                    }
                                }   

                                if(!illegalMove) {
                                    legalMoves.push(position);
                                }
                            }

                            if(!bQRookMoved && activeBoard[7][1] === "" && activeBoard[7][2] === "" && activeBoard[7][3] === "") {
                                position = {
                                    row: piecePosition.row,
                                    col : piecePosition.col-2
                                };

                                let illegalMove = false;
                                let opponentMoves = getAllPossibleMovesOfPlayer("w", board);

                                for(let move of opponentMoves) {
                                    if(move.row === 7 && move.col === 4) {
                                        illegalMove = true;
                                    }
                                }

                                let tempPosition = {
                                    row: piecePosition.row,
                                    col: piecePosition.col-1
                                };

                                let boardAfterTempMove = makeMoveAndReturnNewBoard(piecePosition, tempPosition);
                                let opponentMovesAfterTempMove = getAllPossibleMovesOfPlayer("w", boardAfterTempMove);

                                for(let move of opponentMovesAfterTempMove) {
                                    if(move.row === 7 && move.col === 3) {
                                        illegalMove = true;
                                    }
                                }

                                let boardAfterMove = makeMoveAndReturnNewBoard(piecePosition, position);
                                let opponentMovesAfterMove = getAllPossibleMovesOfPlayer("w", boardAfterMove);

                                for(let move of opponentMovesAfterMove) {
                                    if(move.row === 7 && move.col === 2) {
                                        illegalMove = true;
                                    }
                                }   

                                if(!illegalMove) {
                                    legalMoves.push(position);
                                }
                            }
                        }

                        // Regular king moves
                        for(let j = -1; j < 2; j++) {
                            if(j == 0) {
                                if(piecePosition.col-1 >= 0 && piecePosition.col-1 < 8) {
                                    position = {
                                        row: piecePosition.row,
                                        col : piecePosition.col-1
                                    };

                                    if(getColorOfPieceAtPosition(position, activeBoard) != playerColor) {
                                        if(chessCheck) {
                                            if(!makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                                legalMoves.push(position);
                                            }
                                        } else {
                                            legalMoves.push(position);
                                        }
                                    }
                                }

                                if(piecePosition.col+1 >= 0 && piecePosition.col+1 < 8) {
                                    position = {
                                        row: piecePosition.row,
                                        col : piecePosition.col+1
                                    };

                                    if(getColorOfPieceAtPosition(position, activeBoard) != playerColor) {
                                        if(chessCheck) {
                                            if(!makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                                legalMoves.push(position);
                                            }
                                        } else {
                                            legalMoves.push(position);
                                        }
                                    }
                                }
                                
                            } else {
                                if(piecePosition.row+j >= 0 && piecePosition.row+j < 8) {
                                    for( let k = -1; k < 2; k++) {
                                        if(piecePosition.col+k >= 0 && piecePosition.col+k < 8) {
                                            position = {
                                                row: piecePosition.row+j,
                                                col : piecePosition.col+k
                                            };

                                            if(getColorOfPieceAtPosition(position, activeBoard) != playerColor) {
                                                if(chessCheck) {
                                                    if(!makeMoveAndCheckIfChess(piecePosition, position, playerColor)) {
                                                        legalMoves.push(position);
                                                    }
                                                } else {
                                                    legalMoves.push(position);
                                                }
                                            }
                                        }
                                    }
                                } else {
                                    continue;
                                }
                            }
                        }
                        break;
                }
                return legalMoves;
            }

            function deleteMarker() {
                let marker = document.getElementsByClassName("marker");
                let captureFields = document.getElementsByClassName("catch");

                while(marker[0]) {
                    marker[0].remove();
                }

                while(captureFields[0]) {
                    captureFields[0].classList.remove("catch");
                }

                markedMoves = [];
            }

            function getFieldFromPosition(position) {
                let row = position.row + 1;
                let col;
                
                switch(position.col) {
                    case 0:
                        col = "A";
                        break;
                    case 1:
                        col = "B";
                        break;
                    case 2:
                        col = "C";
                        break;
                    case 3:
                        col = "D";
                        break;
                    case 4:
                        col = "E";
                        break;
                    case 5:
                        col = "F";
                        break;
                    case 6:
                        col = "G";
                        break;
                    case 7:
                        col = "H";
                        break;
                }

                return row+col;
            }

            function markPieceOnFocus(piecePosition) {
                onPieceFocus = true;
                let boardPosition = getFieldFromPosition(piecePosition);
                fieldOnFocus = document.getElementById(boardPosition);
                fieldOnFocus.style.backgroundColor = "#87CEEB";
            }

            function unmarkPiece() {
                pieceOnFocus = null;
                fieldOnFocus.style.backgroundColor = "";
                fieldOnFocus = null;
            }

            function markLegalMoves(positions) {
                for(let position of positions) {
                    let boardPosition = getFieldFromPosition(position);
                    markedMoves.push(boardPosition);
                    let field = document.getElementById(boardPosition);

                    if(checkIfPieceIsOnField(position, board)) {
                        field.classList.add("catch");
                    }

                    let dot = document.createElement("div");
                    dot.classList.add("marker");
                    dot.setAttribute("onclick", "movePiece(this)");
                    dot.innerHTML = "â€¢";
                    field.appendChild(dot);
                }
            }

            function getPieceType(id) {
                let arr = Array.from(id);
                if(arr[1] === 'p') {
                    return arr[0] + arr[1];
                } else {
                    return arr[1];
                }
            }

            function givePosition(boardArray, elementId) {
                for(let i = 0; i < boardArray.length; i++) {
                    for(let j = 0; j < boardArray[i].length; j++) {
                        if(boardArray[i][j] === elementId) {
                            return position = {
                                row: i,
                                col: j
                            };
                        }
                    }
                }
            }

            function fieldIdToBoardPosition(fieldId) {
                let id = Array.from(fieldId);
                let row;
                let col;

                switch(id[0]) {
                    case '1':
                        row = 0;
                        break;
                    case '2':
                        row = 1;
                        break;
                    case '3':
                        row = 2;
                        break;
                    case '4':
                        row = 3;
                        break;
                    case '5':
                        row = 4;
                        break;
                    case '6':
                        row = 5;
                        break;
                    case '7':
                        row = 6;
                        break;
                    case '8':
                        row = 7;
                        break;
                }

                switch(id[1]) {
                    case 'A':
                        col = 0;
                        break;
                    case 'B':
                        col = 1;
                        break;
                    case 'C':
                        col = 2;
                        break;
                    case 'D':
                        col = 3;
                        break;
                    case 'E':
                        col = 4;
                        break;
                    case 'F':
                        col = 5;
                        break;
                    case 'G':
                        col = 6;
                        break;
                    case 'H':
                        col = 7;
                        break;
                }

                return position = {
                    row: row,
                    col: col
                };
            }

            function getAllActivePiecesOfPlayer(player, activeBoard) {
                let activePiecesOfPlayer = [];

                for(let i = 0; i < activeBoard.length; i++) {
                    for(let j = 0; j < activeBoard[i].length; j++) {
                        if(activeBoard[i][j].startsWith(player)) {
                            activePiecesOfPlayer.push(activeBoard[i][j]);
                        }
                    }
                }

                return activePiecesOfPlayer;
            }

            function getAllPossibleMovesOfPlayer(player, activeBoard) {
                let activePiecesOfPlayer = getAllActivePiecesOfPlayer(player, activeBoard);
                let possibleMoves = [];

                for(let piece of activePiecesOfPlayer) {
                    let posi = givePosition(activeBoard, piece);
                    let type = getPieceType(piece);
                    let moves = getLegalMoves(posi, type, activeBoard);

                    for(let move of moves) {
                        possibleMoves.push(move);
                    }
                }
                return possibleMoves;
            }

            function getKingPositionOfPlayer(player, activeBoard) {
                for(let i = 0; i < activeBoard.length; i++) {
                    for (let j = 0; j < activeBoard[i].length; j++) {
                        if(activeBoard[i][j] == player + "k") {
                            return {
                                row: i,
                                col: j
                            }
                        }
                    }
                }
            }

            function checkIfPlayerIsInChess(player, activeBoard) {
                let opponent;

                if(player === "w") {
                    opponent = "b";
                } else {
                    opponent = "w";
                }

                chessCheck = false;
                let possibleMoves = getAllPossibleMovesOfPlayer(opponent, activeBoard);
                let kingsPosition = getKingPositionOfPlayer(player, activeBoard);
                chessCheck = true;

                for(let move of possibleMoves) {
                    if(move.row === kingsPosition.row && move.col === kingsPosition.col) {
                        return true;
                    }
                }
                return false;
            }

            // Initialize the game
            setupGame();
        </script>
    </body>
</html>